group AbstractGR = Statement | AltGR | ParamGR | SliceGR | ArgumentGR | Module | Block | IndentedListBody | ImportPath
group Statement = ReturningStatement | DecoratorGR | ImportStatement | If | For | Assign | StatementExpression | _Pass | _Continue | _Break | _EmptyLine
group ReturningStatement = Raise | Return | Yield | YieldFrom
lemma Raise = 'raise' ?[$' ' Expression -> exc ?[$' ' $'from' $' ' Expression -> cause]]
lemma Return = 'return' ?[$' ' [',' $' '].Expression -> expressions]
lemma Yield = 'yield' ?[$' ' [',' $' '].Expression -> expressions]
lemma YieldFrom = 'yield' $' ' 'from' $' ' Expression -> expr
group DecoratorGR = Decorator | Class | Function
lemma Decorator = '@' Expression -> expr '\n' DecoratorGR -> target
lemma Class = 'class' $' ' Variable -> name ?['(' [',' $' '].Expression -> mro ')'] ':' Block -> block
lemma Function = 'def' $' ' Variable -> name '(' [',' $' '].ParamGR -> args ')' ?[$' ' '->' $' ' Expression -> returns] ':' Block -> block
group ImportStatement = Import | ImportFrom
lemma Import = 'import' $' ' [',' $' '].ImportPath -> targets
lemma ImportFrom = 'from' $' ' ImportPath -> origin $' ' 'import' $' ' [',' $' '].ImportPath -> targets
lemma If = 'if' $' ' Expression -> test ':' Block -> block ?AltGR -> alt
lemma For = 'for' $' ' [',' $' '].Variable -> args $' ' 'in' $' ' Expression -> iter ':' Block -> block
lemma Assign = Primary -> target ?[':' $' ' Expression -> type] ?[$' ' '=' $' ' Expression -> value]
lemma StatementExpression = Expression -> expr
token _Pass = 'pass'
token _Continue = 'continue'
token _Break = 'break'
token _EmptyLine = ''
group AltGR = Elif | Else
lemma Elif = '\n' 'elif' $' ' Expression -> test ':' Block -> block ?AltGR -> alt
lemma Else = '\n' 'else' ':' Block -> block
group ParamGR = Param | ArgsParam | KwargsParam
lemma Param = Variable -> name ?[':' $' ' Expression -> type] ?[$' ' '=' $' ' Expression -> default]
lemma ArgsParam = '*' Variable -> name ?[':' $' ' Expression -> type]
lemma KwargsParam = '**' Variable -> name ?[':' $' ' Expression -> type]
group SliceGR = Expression | Slice
group Expression = Disjunction
group Disjunction = Conjunction | Or
group Conjunction = Inversion | And
group Inversion = Comparison | Not
group Comparison = BitwiseOrGR | Eq | Ne | Le | Lt | Ge | Gt | In | NotIn | Is | IsNot
group BitwiseOrGR = BitwiseXorGR | BitwiseOr
group BitwiseXorGR = BitwiseAndGR | BitwiseXor
group BitwiseAndGR = ShiftGR | BitwiseAnd
group ShiftGR = Sum | LShift | RShift
group Sum = Term | Add | Sub
group Term = Factor | Mul | TrueDiv | FloorDiv | Mod | MatMul
group Factor = Power | Pos | Neg | Inv
group Power = AwaitPrimary | Pow
group AwaitPrimary = Primary | Awaited
group Primary = Atom | GetAttr | GetItem | Call
group Atom = List | Tuple | IndentedList | _True | _False | _None | _Ellipsis | Variable | String | Integer | Decimal
lemma List = '[' ?[[',' $' '].Expression -> items] ']'
lemma Tuple = '(' [',' $' ']..Expression -> items ')'
lemma IndentedList = '[' IndentedListBody -> body '\n' ']'
token _True = 'True'
token _False = 'False'
token _None = 'None'
token _Ellipsis = '...'
token Variable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' *'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
token String = '"' !'"' '"' | "'" !"'" "'"
token Integer = +'0123456789'
token Decimal = +'0123456789' '.' *'0123456789' | '.' +'0123456789'
lemma GetAttr = Primary -> left '.' Variable -> right
lemma GetItem = Primary -> left '[' [',' $' '].SliceGR -> items ']'
lemma Call = Primary -> left '(' [',' $' '].ArgumentGR -> args ')'
lemma Awaited = 'await' $' ' Primary -> right
lemma Pow = AwaitPrimary -> left $' ' '**' $' ' Factor -> right
lemma Pos = '+' Factor -> right
lemma Neg = '-' Factor -> right
lemma Inv = '~' Factor -> right
lemma Mul = Term -> left $' ' '*' $' ' Factor -> right
lemma TrueDiv = Term -> left $' ' '/' $' ' Factor -> right
lemma FloorDiv = Term -> left $' ' '//' $' ' Factor -> right
lemma Mod = Term -> left $' ' '%' $' ' Factor -> right
lemma MatMul = Term -> left $' ' '@' $' ' Factor -> right
lemma Add = Sum -> left $' ' '+' $' ' Term -> right
lemma Sub = Sum -> left $' ' '-' $' ' Term -> right
lemma LShift = ShiftGR -> left $' ' '<<' $' ' Sum -> right
lemma RShift = ShiftGR -> left $' ' '>>' $' ' Sum -> right
lemma BitwiseAnd = BitwiseAndGR -> left $' ' '&' $' ' ShiftGR -> right
lemma BitwiseXor = BitwiseXorGR -> left $' ' '^' $' ' BitwiseAndGR -> right
lemma BitwiseOr = BitwiseOrGR -> left $' ' '|' $' ' BitwiseXorGR -> right
lemma Eq = Comparison -> left $' ' '==' $' ' BitwiseOrGR -> right
lemma Ne = Comparison -> left $' ' '!=' $' ' BitwiseOrGR -> right
lemma Le = Comparison -> left $' ' '<=' $' ' BitwiseOrGR -> right
lemma Lt = Comparison -> left $' ' '<' $' ' BitwiseOrGR -> right
lemma Ge = Comparison -> left $' ' '>=' $' ' BitwiseOrGR -> right
lemma Gt = Comparison -> left $' ' '>' $' ' BitwiseOrGR -> right
lemma In = Comparison -> left $' ' 'in' $' ' BitwiseOrGR -> right
lemma NotIn = Comparison -> left $' ' 'not' $' ' 'in' $' ' BitwiseOrGR -> right
lemma Is = Comparison -> left $' ' 'is' $' ' BitwiseOrGR -> right
lemma IsNot = Comparison -> left $' ' 'is' $' ' 'not' $' ' BitwiseOrGR -> right
lemma Not = 'not' Inversion -> right
lemma And = [$' ' 'and' $' ']..Inversion -> items
lemma Or = [$' ' 'or' $' ']..Conjunction -> items
lemma Slice = ?Expression -> first ':' ?Expression -> second ?[':' Expression -> third]
group ArgumentGR = Kwarg | StarredExpression | DoubleStarred | Expression
lemma Kwarg = Variable -> name '=' Expression -> value
lemma StarredExpression = '*' Expression -> value
lemma DoubleStarred = '**' Expression -> value
lemma Module = '\n'..Statement -> statements
lemma:i Block = +['\n' Statement -> statements]
lemma:i IndentedListBody = +['\n' Expression -> items ',']
lemma ImportPath = '.'.Variable -> parts
entry AbstractGR