group Atom = Variable | _True | _False | _None | String | Integer | Decimal
token Variable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' *'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
token _True = 'True'
token _False = 'False'
token _None = 'None'
token String = '"' !'"' '"' | "'" !"'" "'"
token Integer = +'0123456789'
token Decimal = +'0123456789' '.' *'0123456789' | '.' +'0123456789'
lemma Module = '\n'..<Statement in statements>
lemma Raise = 'raise' ?[$' ' <Expression as exc> ?[$' ' $'from' $' ' <Expression as cause>]]
lemma Return = 'return' ?[$' ' [',' $' '].<Expression in expressions>]
lemma Yield = 'yield' ?[$' ' [',' $' '].<Expression in expressions>]
lemma YieldFrom = 'yield' $' ' 'from' $' ' <Expression as expr>
group Expression = Disjunction
group Disjunction = Or | Conjunction
lemma Or = <Disjunction as left> $' ' 'or' $' ' <Conjunction as right>
group Conjunction = And | Inversion
lemma And = <Conjunction as left> $' ' 'and' $' ' <Inversion as right>
group Inversion = Not | Comparison
lemma Not = 'not' <Inversion as right>
group Comparison = Eq | Ne | Le | Lt | Ge | Gt | In | NotIn | Is | IsNot | BitwiseOrGR
lemma Eq = <Comparison as left> $' ' '==' $' ' <BitwiseOrGR as right>
lemma Ne = <Comparison as left> $' ' '!=' $' ' <BitwiseOrGR as right>
lemma Le = <Comparison as left> $' ' '<=' $' ' <BitwiseOrGR as right>
lemma Lt = <Comparison as left> $' ' '<' $' ' <BitwiseOrGR as right>
lemma Ge = <Comparison as left> $' ' '>=' $' ' <BitwiseOrGR as right>
lemma Gt = <Comparison as left> $' ' '>' $' ' <BitwiseOrGR as right>
lemma In = <Comparison as left> $' ' 'in' $' ' <BitwiseOrGR as right>
lemma NotIn = <Comparison as left> $' ' 'not' $' ' 'in' $' ' <BitwiseOrGR as right>
lemma Is = <Comparison as left> $' ' 'is' $' ' <BitwiseOrGR as right>
lemma IsNot = <Comparison as left> $' ' 'is' $' ' 'not' $' ' <BitwiseOrGR as right>
group BitwiseOrGR = BitwiseOr | BitwiseXorGR
lemma BitwiseOr = <BitwiseOrGR as left> $' ' '|' $' ' <BitwiseXorGR as right>
group BitwiseXorGR = BitwiseXor | BitwiseAndGR
lemma BitwiseXor = <BitwiseXorGR as left> $' ' '^' $' ' <BitwiseAndGR as right>
group BitwiseAndGR = BitwiseAnd | ShiftGR
lemma BitwiseAnd = <BitwiseAndGR as left> $' ' '&' $' ' <ShiftGR as right>
group ShiftGR = LShift | RShift | Sum
lemma LShift = <ShiftGR as left> $' ' '<<' $' ' <Sum as right>
lemma RShift = <ShiftGR as left> $' ' '>>' $' ' <Sum as right>
group Sum = Add | Sub | Term
lemma Add = <Sum as left> $' ' '+' $' ' <Term as right>
lemma Sub = <Sum as left> $' ' '-' $' ' <Term as right>
group Term = Mul | TrueDiv | FloorDiv | Mod | MatMul | Factor
lemma Mul = <Term as left> $' ' '*' $' ' <Factor as right>
lemma TrueDiv = <Term as left> $' ' '/' $' ' <Factor as right>
lemma FloorDiv = <Term as left> $' ' '//' $' ' <Factor as right>
lemma Mod = <Term as left> $' ' '%' $' ' <Factor as right>
lemma MatMul = <Term as left> $' ' '@' $' ' <Factor as right>
group Factor = Pos | Neg | Inv | Power
lemma Pos = '+' <Factor as right>
lemma Neg = '-' <Factor as right>
lemma Inv = '~' <Factor as right>
group Power = Pow | AwaitPrimary
lemma Pow = <AwaitPrimary as left> $' ' '**' $' ' <Factor as right>
group AwaitPrimary = Awaited | Primary
lemma Awaited = 'await' $' ' <Primary as right>
group Primary = GetAttr | GetItem | Call | Atom
lemma GetAttr = <Primary as left> '.' <Variable as right>
lemma GetItem = <Primary as left> '[' [',' $' '].<SliceGR in items> ']'
lemma Call = <Primary as left> '(' [',' $' '].<ArgumentGR in args> ')'
lemma Slice = ?<Expression as first> ':' ?<Expression as second> ?[':' <Expression as third>]
lemma Kwarg = <Variable as name> '=' <Expression as value>
lemma StarredExpression = '*' <Expression as value>
lemma DoubleStarred = '**' <Expression as value>
group AbstractGR = Module | Statement | SliceGR | ArgumentGR | Block
group Statement = ReturningStatement | DecoratorGR
group ReturningStatement = Return | Raise | Yield | YieldFrom
group SliceGR = Slice | Expression
group ArgumentGR = Kwarg | StarredExpression | DoubleStarred | Expression
group DecoratorGR = Decorator | Class | Function
lemma Decorator = '@' <Expression as expr> '\n' <DecoratorGR as target>
lemma Class = 'class' $' ' <Variable as name> ?['(' [',' $' '].<Expression in mro> ')'] ':' <Block as block>
lemma Function = 'def' $' ' <Variable as name> '(' [',' $' '].<Expression in args> ')' ?[$' ' '->' $' ' <Expression as returns>] ':' <Block as block>
lemma Block = +['\n' <Statement in statements>]
entry Module