group AbstractGR = Statement | AltGR | ParamGR | SliceGR | ArgumentGR | Module | Block | IndentedListBody | ImportPath
group Statement = ReturningStatement | DecoratorGR | ImportStatement | If | For | Assign | StatementExpression | _Pass | _Continue | _Break | _EmptyLine
group ReturningStatement = Raise | Return | Yield | YieldFrom
lemma Raise = 'raise' ?[$' ' <Expression as exc> ?[$' ' $'from' $' ' <Expression as cause>]]
lemma Return = 'return' ?[$' ' [',' $' '].<Expression in expressions>]
lemma Yield = 'yield' ?[$' ' [',' $' '].<Expression in expressions>]
lemma YieldFrom = 'yield' $' ' 'from' $' ' <Expression as expr>
group DecoratorGR = Decorator | Class | Function
lemma Decorator = '@' <Expression as expr> '\n' <DecoratorGR as target>
lemma Class = 'class' $' ' <Variable as name> ?['(' [',' $' '].<Expression in mro> ')'] ':' <Block as block>
lemma Function = 'def' $' ' <Variable as name> '(' [',' $' '].<ParamGR in args> ')' ?[$' ' '->' $' ' <Expression as returns>] ':' <Block as block>
group ImportStatement = Import | ImportFrom
lemma Import = 'import' $' ' [',' $' '].<ImportPath in targets>
lemma ImportFrom = 'from' $' ' <ImportPath as origin> $' ' 'import' $' ' [',' $' '].<ImportPath in targets>
lemma If = 'if' $' ' <Expression as test> ':' <Block as block> ?<AltGR as alt>
lemma For = 'for' $' ' [',' $' '].<Variable in args> $' ' 'in' $' ' <Expression as iter> ':' <Block as block>
lemma Assign = <Primary as target> ?[':' $' ' <Expression as type>] ?[$' ' '=' $' ' <Expression as value>]
lemma StatementExpression = <Expression as expr>
token _Pass = 'pass'
token _Continue = 'continue'
token _Break = 'break'
token _EmptyLine = ''
group AltGR = Elif | Else
lemma Elif = '\n' 'elif' $' ' <Expression as test> ':' <Block as block> ?<AltGR as alt>
lemma Else = '\n' 'else' ':' <Block as block>
group ParamGR = Param | ArgsParam | KwargsParam
lemma Param = <Variable as name> ?[':' $' ' <Expression as type>] ?[$' ' '=' $' ' <Expression as default>]
lemma ArgsParam = '*' <Variable as name> ?[':' $' ' <Expression as type>]
lemma KwargsParam = '**' <Variable as name> ?[':' $' ' <Expression as type>]
group SliceGR = Expression | Slice
group Expression = Disjunction
group Disjunction = Conjunction | Or
group Conjunction = Inversion | And
group Inversion = Comparison | Not
group Comparison = BitwiseOrGR | Eq | Ne | Le | Lt | Ge | Gt | In | NotIn | Is | IsNot
group BitwiseOrGR = BitwiseXorGR | BitwiseOr
group BitwiseXorGR = BitwiseAndGR | BitwiseXor
group BitwiseAndGR = ShiftGR | BitwiseAnd
group ShiftGR = Sum | LShift | RShift
group Sum = Term | Add | Sub
group Term = Factor | Mul | TrueDiv | FloorDiv | Mod | MatMul
group Factor = Power | Pos | Neg | Inv
group Power = AwaitPrimary | Pow
group AwaitPrimary = Primary | Awaited
group Primary = Atom | GetAttr | GetItem | Call
group Atom = List | Tuple | IndentedList | Variable | _True | _False | _None | String | Integer | Decimal | _Ellipsis
lemma List = '[' ?[[',' $' '].<Expression in items>] ']'
lemma Tuple = '(' [',' $' ']..<Expression in items> ')'
lemma IndentedList = '[' <IndentedListBody as body> '\n' ']'
token Variable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz' *'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'
token _True = 'True'
token _False = 'False'
token _None = 'None'
token String = '"' !'"' '"' | "'" !"'" "'"
token Integer = +'0123456789'
token Decimal = +'0123456789' '.' *'0123456789' | '.' +'0123456789'
token _Ellipsis = '...'
lemma GetAttr = <Primary as left> '.' <Variable as right>
lemma GetItem = <Primary as left> '[' [',' $' '].<SliceGR in items> ']'
lemma Call = <Primary as left> '(' [',' $' '].<ArgumentGR in args> ')'
lemma Awaited = 'await' $' ' <Primary as right>
lemma Pow = <AwaitPrimary as left> $' ' '**' $' ' <Factor as right>
lemma Pos = '+' <Factor as right>
lemma Neg = '-' <Factor as right>
lemma Inv = '~' <Factor as right>
lemma Mul = <Term as left> $' ' '*' $' ' <Factor as right>
lemma TrueDiv = <Term as left> $' ' '/' $' ' <Factor as right>
lemma FloorDiv = <Term as left> $' ' '//' $' ' <Factor as right>
lemma Mod = <Term as left> $' ' '%' $' ' <Factor as right>
lemma MatMul = <Term as left> $' ' '@' $' ' <Factor as right>
lemma Add = <Sum as left> $' ' '+' $' ' <Term as right>
lemma Sub = <Sum as left> $' ' '-' $' ' <Term as right>
lemma LShift = <ShiftGR as left> $' ' '<<' $' ' <Sum as right>
lemma RShift = <ShiftGR as left> $' ' '>>' $' ' <Sum as right>
lemma BitwiseAnd = <BitwiseAndGR as left> $' ' '&' $' ' <ShiftGR as right>
lemma BitwiseXor = <BitwiseXorGR as left> $' ' '^' $' ' <BitwiseAndGR as right>
lemma BitwiseOr = <BitwiseOrGR as left> $' ' '|' $' ' <BitwiseXorGR as right>
lemma Eq = <Comparison as left> $' ' '==' $' ' <BitwiseOrGR as right>
lemma Ne = <Comparison as left> $' ' '!=' $' ' <BitwiseOrGR as right>
lemma Le = <Comparison as left> $' ' '<=' $' ' <BitwiseOrGR as right>
lemma Lt = <Comparison as left> $' ' '<' $' ' <BitwiseOrGR as right>
lemma Ge = <Comparison as left> $' ' '>=' $' ' <BitwiseOrGR as right>
lemma Gt = <Comparison as left> $' ' '>' $' ' <BitwiseOrGR as right>
lemma In = <Comparison as left> $' ' 'in' $' ' <BitwiseOrGR as right>
lemma NotIn = <Comparison as left> $' ' 'not' $' ' 'in' $' ' <BitwiseOrGR as right>
lemma Is = <Comparison as left> $' ' 'is' $' ' <BitwiseOrGR as right>
lemma IsNot = <Comparison as left> $' ' 'is' $' ' 'not' $' ' <BitwiseOrGR as right>
lemma Not = 'not' <Inversion as right>
lemma And = [$' ' 'and' $' ']..<Inversion in items>
lemma Or = [$' ' 'or' $' ']..<Conjunction in items>
lemma Slice = ?<Expression as first> ':' ?<Expression as second> ?[':' <Expression as third>]
group ArgumentGR = Kwarg | StarredExpression | DoubleStarred | Expression
lemma Kwarg = <Variable as name> '=' <Expression as value>
lemma StarredExpression = '*' <Expression as value>
lemma DoubleStarred = '**' <Expression as value>
lemma Module = '\n'..<Statement in statements>
lemma:i Block = +['\n' <Statement in statements>]
lemma:i IndentedListBody = +['\n' <Expression in items> ',']
lemma ImportPath = '.'.<Variable in parts>
entry AbstractGR